\documentclass[11pt]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ersetzen Sie in den folgenden Zeilen die entsprechenden -Texte-
%% mit den richtigen Werten.
\newcommand{\theNumber}{1.77}
\newcommand{\theGroup}{$\pi$}
\newcommand{\theName}{Kugelkondensator mit verschiedenen Dielektrika}

\newcommand{\nameM}{Moritz Mackiewicz}
\newcommand{\nameE}{Elias Marquart}
\newcommand{\nameC}{Claus Strasburger}
%%%%%%%%%%%

\input{asp_standard_lib}
%\include{__config}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}

\begin{document}

\sheetHeader{Projektaufgabe \theNumber : \theName}{Gruppe \theGroup:}{\nameM}{\nameE}{\nameC}

\section{Problemstellung und Spezifikation}

\subsection{Aufgabenstellung}
\paragraph{}
In der von uns bearbeiteten Aufgabe geht es um die Berechnung der Kapazitäten von mehreren Kugelkondensatoren.

Ein Kugelkondensator besteht aus zwei konzentrisch angeordneten Kugeln, die durch ein Isoliermaterial, genannt \emph{Dielektrikum}, getrennt werden. Die Kapazität des resultierenden Kondensators hängt von dem Verhältnis der Radien der beiden Kugeln und dem verwendeten Dielektrikum ab.

Dazu wird eine Liste von Radien --- jeweils für den Radius der inneren und der äußeren Kugel --- in Form einer Textdatei eingegeben. Zu dieser werden dann in einem Assemblerprogramm die jeweiligen Kapazitäten für verschiedene Dielektrika berechnet.
Die Abmessungen bestehen jeweils aus zwei Radien, dem der inneren Kugel $r_{1}$ und dem der äußeren Kugel $r_{2}$.

Die Formel zur Berechnung der Kapazität eines Kugelkondensators lautet:

\begin{center} \begin{LARGE}
$ C= 4 \pi \varepsilon_{0} \varepsilon_{r} \frac{r_{1} \cdot r_{2}} {r_{2} - r_{1}} $
\end{LARGE} \end{center}

\subsection{Implementierungsumgebung}
Wir verwenden zur Entwicklung das \board, ein ARM Cortex-A8-System mit NEON-VFP. Die NEON-Architektur erlaubt es, bis zu vier Fließkommazahlen in einem Schritt zu verrechnen, wodurch eine hohe Performanz beim \emph{Number Crunching} erreicht wird. Dieses Verfahren wird \emph{SIMD} genannt.\\
Beispiele für Fließkommaintensive Berechnungen sind Audioverarbeitung, 3D-Visualisierungen oder Physik-Simulationen.
\\ \\
Unsere Entwicklungsumgebung besteht aus \emph{ARM Development Studio 5 für Eclipse}, \emph{GNU make} und \emph{gcc 4.7}.

DS-5 ist eine auf Eclipse aufgebaute Umgebung, die eine einfach zu benutzende graphische Oberfläche zum Entwickeln, Ausführen und Debuggen von Programmen für ARM-Systeme bereitstellt. Die Einrichtung ist jedoch etwas umständlich, da DS-5 nicht ganz fehlerfrei ist und keinen klaren Leitfaden zum Erstellen eines Projekts bietet.

GCC ist eine der weitverbreitesten Compilersuiten, ist vollständig Open-Source und in der Lage, für alle bekannten Architekturen und Betriebssysteme C, C++ und Assemblercode zu Binärcode umzubauen, wobei zusätzlich auch umfangreiche und effektive Optimisierungsoptionen vorhanden sind.

\section{Lösungsalternativen}
\subsection{Vector Floating Point (VFP)}
\subsection*{Vorstellung}
In der von uns enwickelten Lösung verwenden wir die Vector Floating Point Erweiterung von ARM. 
Diese erlaubt es uns mit Fließkommazahlen zu rechnen.
\subsection*{Vorteile}
\begin{itemize}
\item beliebige Menge an zu verarbeitenden Daten
\item lauffähig auch auf Architekturen ohne NEON
\end{itemize}
\subsection*{Nachteile}
\begin{itemize}
\item langsam, da der VFP-Koprozessor nicht voll genutzt wird
\end{itemize}
\subsection{SIMD (NEON-Coprozessor)}
In dieser alternativen Lösung wird der NEON Coprozessor von ARM verwendet, um von \emph{SIMD} (Single Instruction, Multiple Data)
zu profitieren. Das bedeutet, dass pro Assemblerbefehl nicht mit einem, sondern mit vier Zahlen gleichzeitig gerechnet werden kann. Unsere Tests haben gezeigt, dass dadurch die Berechnung mindestens um den Faktor 6 beschleunigt wird.
\subsubsection{Vorteile}
\begin{itemize}
\item Um Faktor 6-8 schneller als VFP
\end{itemize}
\subsubsection{Nachteile}
\begin{itemize}
\item SIMD Befehle müssen jeweils zwei oder vier Fließkommazahlen verarbeiten. Falls die Eingabedatenmenge kein Vielfaches von vier ist, kann für den entsprechenden Rest nicht derselbe Code verwendet werden.
\item Der NEON Befehlssatz verfügt über keinen Divisionsbefehl. Die einzige Möglichkeit ist eine Annäherung an den Kehrbruch mit \emph{VRECPE} und anschließende Multiplikation.
Die einmalige Annäherung ist dadurch nicht sehr genau, durch zweimalige Iteration des Newton-Raphson-Verfahrens mittels \emph{VRECPS} erreichen wir jedoch eine Genauigkeit von ~7 signifikanten Stellen, was sich als am praktikabelsten herausgestellt hat. 
\end{itemize}
\subsection{Entscheidungsprozess}
Um keine Entscheidung zugunsten einer Lösung treffen zu müssen, haben wir einfach alle Alternativen selbst implementiert, wobei bei der NEON-Variante nur der Berechnungsteil in Assembler umgesetzt wurde, die Schleifenstruktur zur Übergabe der Daten wurde dagegen in C geschrieben.
\section{Dokumentation der Implementierung}
\subsection{Entwickler-Dokumentation}
\subsubsection{Rahmenprogramm}
Das in C geschriebene Rahmenprogramm liest die Datensätze mit den Radien der Kugelkondensatoren aus einer Textdatei in den Speicher.
Dann werden drei verschiedene Implementierungsvarianten ausgeführt (Assembler mit VFP, Assembler mit NEON und Vektorisierung und die C-Referenzimplementierung), deren Ergebnisse ausgegeben werden und die dafür benötigte Zeit (in Mikrosekunden) gemessen wird.
\\\\
Zunächst werden über die Methode \emph{$datei\_lesen$} die in der Datei \emph{$ui.txt$} stehenden Datensätze eingelesen. Die einzulesende Datei muss dabei folgenden Richtlinien folgen:
\begin{verse}
$ $ Zeile 1: $\; \textbf{$n-1$} $ \\
$ $ Zeile 2: $\; \textbf{$[x_{0}]_{r_{1}}$} \: $mm$ \:\emph{$[x_{0}]_{r_{2}}$} \: $mm$ $ \\
$\vdots $\\
$ $ Zeile n: $\; \textbf{$[x_{n-1}]_{r_{1}}$} \: $mm$ \:\emph{$[x_{n-1}]_{r_{2}}$} \: $mm$ $
\end{verse}
Hierbei ist $x$ mit der Mächtigkeit $\vert x \vert = n$ die Menge aus den zu berechnenden Datensätzen bestehend aus den 2-Tupeln $(r_{1},r_{2})\in \mathbb{R}^{2} $, wobei $r_{1}$ den Radius der inneren Kugel und $r_{2}$ den Radius der äußeren Kugel bezeichnet.\\\\
Im folgenden wird auf die Arbeitsweise dieser Methode anhand von Auszügen aus dem Quelltext eingegangen.
\begin{verbatim}
FILE* handle = NULL;
\end{verbatim}
Erzeugt eine Variable namens \emph{$handle$}, in der ein Pointer auf ein \emph{$FILE$}-Struct, definiert in der Headerdatei \emph{$stdio.h$} (Teil der Standard-C-Bibliotheken) gespeichert werden kann. Damit wird ein späterer Zugriff auf die einzulesende Datei ermöglicht. Zunächst wird die Variable aber auf \emph{$NULL$} gesetzt, weil noch keine Datei geöffnet wurde.
\begin{verbatim}
char line[MAX_LINE_LENGTH];
\end{verbatim}
Erzeugt eine Variable namens \emph{$line$}, in der ein Array der Größe \emph{$MAX\_LINE\_LENGTH$} (als \emph{1024} definiert) mit Elementen vom Typ \emph{$char$} gespeichert wird. Benötigt wird diese Variable zum Speichern des Inhalts der aktuellen Zeile in der einzulesenden Datei.
%%TODO: Wieso funktionieren hier keine Tabs?
\begin{verbatim}
	handle = fopen(filename, "r");
	if(!handle) {
			fprintf(stderr,"FEHLER: Datei konnte nicht geoeffnet werden!\n");
			return 1; 
	}
\end{verbatim}
Mit \emph{fopen} wird versucht die Datei, die unter dem Pfad spezifiziert vom Parameter \emph{filename} zu finden ist, im Lesemodus (deshalb das \emph{"r"} als zweiter Parameter) zu öffnen und anschließend eine Zugriffsreferenz für die spätere Verwendung unter der vorher definierten Variable \emph{handle} zu sichern. Schlägt dies fehl, d.h. \emph{handle} hat den Wert \emph{0}, wird eine entsprechende Ausgabe an den systemweiten Error-Stream gesendet und die Methode mit dem Rückgabewert \emph{1} abgebrochen.
\begin{verbatim}
if(feof(handle) || fgets(line, MAX_LINE_LENGTH, handle)==NULL) {
		fprintf(stderr,"Fehler: Datei ist leer\n");
		return 1;
	}
\end{verbatim}
Hier wird überprüft, ob es sich bei der einzulesenden Datei um eine leere Datei handelt bzw. von der Datei überhaupt gelesen werden kann. Zunächst wird mittels \emph{feof} sichergestellt, dass das Ende des Dateistreams noch nicht erreicht ist, um anschließend zu überprüfen ob die erste Zeile gelesen werden kann. Die Methode \emph{fgets} erwartet hierbei einen Pointer auf ein \emph{char}-Array (\emph{line}), in das bei einem erfolgreichen Lesevorgang die nächsten \emph{1024} (\emph{MAX\_LINE\_LENGTH}) Zeichen des Streams \emph{handle} geschrieben werden. Schlägt einer der Tests fehl, wird wiederum eine entsprechende Ausgabe an den systemweiten Error-Stream gesendet und die Methode mit dem Rückgabewert \emph{1} abgebrochen.
\begin{verbatim}
	*length = atoi(line);
	if(*length <= 0) {
		fprintf(stderr, "Fehler: '%s' ist keine sinnvolle Zeilennummer\n", line);
		return 1;
	}
\end{verbatim}
Um die Größe des Datensatzes herauszufinden, wird hier der Inhalt der ersten Zeile mittels \emph{atoi} in einen \emph{Integer} umgewandelt, der dann im vom Parameter \emph{length} referenzierten Speicher gesichert wird. Um fehlerhafte Daten auszuschließen, wird danach überprüft, ob es sich eine sinnvolle Länge handelt ($>0$). Ist dies nicht der Fall wird eine entsprechende Fehlermeldung ausgegeben und die Methode mit dem Rückgabewert \emph{1} abgebrochen.
\begin{verbatim}
	*rad1 = (float*)malloc(*length * sizeof(float));
	*rad2 = (float*)malloc(*length * sizeof(float));
	if(!rad1 || !rad2) {
		fprintf(stderr,"Fehler: keinen Speicher bekommen\n");
		return 1;
	}
\end{verbatim}
Zunächst wird für die inneren (\emph{rad1}) und äußeren (\emph{rad2}) Radien der Kugelkondensatoren des Datensatzes versucht, entsprechend großen Speicher zu allozieren (Länge des Datensatzes multipliziert mit der Größe der Daten selbst, die ja aus \emph{float}s bestehen). Anschließend wird überprüft, ob dieser Vorgang erfolgreich ausgeführt werden konnte, wobei bei einem Fehler ähnliches passiert wie in den vorangehenden Absätzen.
\\\\
Die nachfolgende Schleife versucht, die Datei zeilenweise einzulesen und die dabei gewonnenen Daten im passenden Speicherbereich zu sichern. Dabei wird jeweils ähnlich wie zu Beginn der Methode sichergestellt, dass weder das Ende der Datei erreicht noch eine leere Zeile erwischt wurde.
\begin{verbatim}
if(sscanf(line, "%f mm %f mm", (*rad1+index), (*rad2+index)) != 2) {
			fprintf(stderr, "Fehler in Z. %d: %s\n", index, line);
			fprintf(stderr, "Ich bin mal weg\n");
			return 1;
		}
\end{verbatim}
Die Daten in der aktuellen Zeile der Datei werden hier mittels \emph{sscanf} extrahiert und an der entsprechenden Position in den Arrays gespeichert. Die Parameter dieser Funktion verhalten sich dabei ähnlich wie \emph{sprintf}, nur die Funktionsweise ist umgekehrt. Der Rückgabewert ist dabei gleich der erfolgreich ausgelesenen Werte, wenn dieser also nicht \emph{2} ist, was bedeuten würde, dass die aktuelle Zeile ein ungültiges Format hat, wird das Einlesen abgebrochen und eine entsprechende Fehlermeldung ausgegeben. Außerdem werden Gegenmaßnahmen durchgeführt, falls in der Datei zu viele (> \emph{length}, restliche Daten werden ignoriert) oder zu wenige (< \emph{length}, \emph{length} wird entsprechend geändert) Daten zu finden sind.\\
Nun sollte sichergestellt sein, dass gültige Daten eingelesen wurden, diese werden dann, nachdem genügend großer Speicher für die Ergebnisse alloziert wurde der Assemblerroutine übergeben.

\subsubsection{Assemblerroutine - VFP}
%%loop
%%capacity
%%TODO
\subsubsection{Assemblerroutine - NEON und Vektorisierung}
%%TODO
Da wir uns zunächst für eine Implementierung ohne Vektorisierung entschieden haben, haben wir den Aufrufcode nicht an die Vektorisierung angepasst und haben das NEON-Beispiel direkt mittels C-Code angesprochen. 
\subsubsection{Optimierungen}
%%TODO
\subsection{Benutzer-Dokumentation}
%%TODO
\section{Ergebnisse}
\subsection{Vergleich von Assembler und C-Code}
\subsubsection{Genauigkeit der Ergebnisse}
%%TODO
\subsubsection{Laufzeit}
%%TODO
\subsection{Analyse und Bewertung}
%%TODO

\end{document}

\documentclass[11pt]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ersetzen Sie in den folgenden Zeilen die entsprechenden -Texte-
%% mit den richtigen Werten.
\newcommand{\theNumber}{1.77}
\newcommand{\theGroup}{$\pi$}
\newcommand{\theName}{Kugelkondensator mit verschiedenen Dielektrika}

\newcommand{\nameM}{Moritz Mackiewicz}
\newcommand{\nameE}{Elias Marquart}
\newcommand{\nameC}{Claus Strasburger}
%%%%%%%%%%%

\input{asp_standard_lib}
%\include{__config}
\usepackage{hyperref}
\usepackage{amsmath}

\begin{document}

\sheetHeader{Projektaufgabe \theNumber : \theName}{Gruppe \theGroup:}{\nameM}{\nameE}{\nameC}

\section{Problemstellung und Spezifikation}

\subsection{Aufgabenstellung}
\paragraph{}
In der von uns bearbeiteten Aufgabe geht es um die Berechnung der Kapazitäten von mehreren Kugelkondensatoren.

Ein Kugelkondensator besteht aus zwei konzentrisch angeordneten Kugeln, die durch ein Isoliermaterial, genannt \emph{Dielektrikum}, getrennt werden. Die Kapazität des resultierenden Kondensators hängt von dem Verhältnis der Radien der beiden Kugeln und dem verwendeten Dielektrikum ab.

Dazu wird eine Liste von Radien --- jeweils für den Radius der inneren und der äußeren Kugel --- in Form einer Textdatei eingegeben. Zu dieser werden dann in einem Assemblerprogramm die jeweiligen Kapazitäten für verschiedene Dielektrika berechnet.
Die Abmessungen bestehen jeweils aus zwei Radien, dem der inneren Kugel $r_{1}$ und dem der äußeren Kugel $r_{2}$.

Die Formel zur Berechnung der Kapazität eines Kugelkondensators lautet:

\begin{center} \begin{LARGE}
$ C= 4 \pi \varepsilon_{0} \varepsilon_{r} \frac{r_{1} \cdot r_{2}} {r_{2} - r_{1}} $
\end{LARGE} \end{center}

\subsection{Implementierungsumgebung}
Wir verwenden zur Entwicklung das \board, ein ARMv8-System mit NEON-VFP. Die NEON-Architektur erlaubt es, bis zu vier Fließkommazahlen in einem Schritt zu verrechnen, wodurch eine hohe Performanz beim \emph{Number Crunching} erreicht wird. Dieses Verfahren wird \emph{SIMD} genannt.\\
Beispiele für Fließkommaintensive Berechnungen sind Audioverarbeitung, 3D-Visualisierungen oder Physik-Simulationen.
\\ \\
Unsere Entwicklungsumgebung besteht aus \emph{ARM Development Studio 5 für Eclipse}, \emph{GNU make} und \emph{gcc 4.7}.

\section{Lösungsalternativen}
\subsection{Unsere Lösung -- Vector Floating Point (VFP)}
\subsection*{Vorstellung}
In der von uns enwickelten Lösung verwenden wir die Vector Floating Point Erweiterung von ARM. 
Diese erlaubt es uns mit Fließkommazahlen zu rechnen.
\subsection*{Vorteile}
\begin{itemize}
\item beliebige Menge an zu verarbeitenden Daten
\item lauffähig auch auf Architekturen ohne NEON
\end{itemize}
\subsection*{Nachteile}
\begin{itemize}
\item Langsam, da der VFP-Koprozessor nicht voll genutzt wird
\end{itemize}
\subsection{Alternative Lösung -- SIMD (NEON)}
In dieser alternativen Lösung wird der NEON Koprozessor von ARM verwendet, um von \emph{SIMD} (Single Instruction, Multiple Data)
zu profitieren. Das bedeutet, dass pro Assemblerbefehl nicht mit einem, sondern mit vier Zahlen gerechnet werden. Unsere Tests haben gezeigt, dass dadurch die Berechnung mindestens um Faktor 6 verschnellert wird.
\subsubsection{Vorteile}
\begin{itemize}
\item Um Faktor 6-8 schneller als VFP
\end{itemize}
\subsubsection{Nachteile}
\begin{itemize}
\item SIMD Befehle müssen jeweils zwei oder vier Fließkommazahlen verarbeiten. Falls die Eingabedatenmenge kein Vielfaches von vier ist, kann für den entsprechenden Rest nicht derselbe Code verwendet werden.
\item Der NEON Befehlssatz verfügt über keinen Divisionsbefehl. Die einzige Möglichkeit ist eine Annäherung an den Kehrbruch mit \emph{VRECPE} und anschließende Multiplikation. 
Jedoch ist die einmalige Annäherung dadurch nicht sehr genau, wir erreichen jedoch durch zweimalige Iteration des Newton-Raphson-Verfahrens unter Zuhilfenahme von \emph{VRECPS} eine Genauigkeit von ~7 signifikanten Stellen, was sich als am praktikabelsten herausgestellt hat. 
\end{itemize}
\subsection{Entscheidungsprozess}
Um keine Entscheidung zugunsten einer Lösung treffen zu müssen, haben wir einfach alle Alternativen selbst implementiert.
\section{Dokumentation der Implementierung}
\subsection{Entwickler-Dokumentation}
\subsubsection{Rahmenprogramm}
\subsubsection{Assemblerroutine}
\subsubsection{Optimierungen}
\subsection{Benutzer-Dokumentation}

\section{Ergebnisse}
\subsection{Vergleich von Assembler und C-Code}
\subsubsection{Genauigkeit der Ergebnisse}
\subsubsection{Laufzeit}
\subsection{Analyse und Bewertung}




\end{document}

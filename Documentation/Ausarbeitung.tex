\documentclass[11pt]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ersetzen Sie in den folgenden Zeilen die entsprechenden -Texte-
%% mit den richtigen Werten.
\newcommand{\theNumber}{1.77}
\newcommand{\theGroup}{$\pi$}
\newcommand{\theName}{Kugelkondensator mit verschiedenen Dielektrika}

\newcommand{\nameM}{Moritz Mackiewicz}
\newcommand{\nameE}{Elias Marquart}
\newcommand{\nameC}{Claus Strasburger}
%%%%%%%%%%%

\input{asp_standard_lib}
%\include{__config}
\usepackage{hyperref}
\usepackage{amsmath}

\begin{document}

\sheetHeader{Projektaufgabe \theNumber : \theName}{Gruppe \theGroup:}{\nameM}{\nameE}{\nameC}

\section{Problemstellung und Spezifikation}

\subsection{Aufgabenstellung}
\paragraph{}
In der von uns bearbeiteten Aufgabe geht es um die Berechnung der Kapazitäten von mehreren Kugelkondensatoren.

Ein Kugelkondensator besteht aus zwei konzentrisch angeordneten Kugeln, die durch ein Isoliermaterial, genannt \emph{Dielektrikum}, getrennt werden. Die Kapazität des resultierenden Kondensators hängt von dem Verhältnis der Radien der beiden Kugeln und dem verwendeten Dielektrikum ab.

Dazu wird eine Liste von Radien --- jeweils für den Radius der inneren und der äußeren Kugel --- in Form einer Textdatei eingegeben. Zu dieser werden dann in einem Assemblerprogramm die jeweiligen Kapazitäten für verschiedene Dielektrika berechnet.
Die Abmessungen bestehen jeweils aus zwei Radien, dem der inneren Kugel $r_{1}$ und dem der äußeren Kugel $r_{2}$.

Die Formel zur Berechnung der Kapazität eines Kugelkondensators lautet:

\begin{center} \begin{LARGE}
$ C= 4 \pi \varepsilon_{0} \varepsilon_{r} \frac{r_{1} \cdot r_{2}} {r_{2} - r_{1}} $
\end{LARGE} \end{center}

\subsection{Implementierungsumgebung}
Wir verwenden zur Entwicklung das \board, ein ARMv8-System mit NEON-VFP. Die NEON-Architektur erlaubt es, bis zu vier Fließkommazahlen in einem Schritt zu verrechnen, wodurch eine hohe Performanz beim \emph{Number Crunching} erreicht wird. Dieses Verfahren wird \emph{SIMD} genannt.\\
Beispiele für Fließkommaintensive Berechnungen sind Audioverarbeitung, 3D-Visualisierungen oder Physik-Simulationen.
\\ \\
Unsere Entwicklungsumgebung besteht aus \emph{ARM Development Studio 5 für Eclipse}, \emph{GNU make} und \emph{gcc 4.7}.

DS-5 ist eine auf Eclipse aufgebaute Umgebung, die eine einfach zu benutzende graphische Oberfläche zum Entwickeln, Ausführen und Debuggen von Programmen für ARM-Systeme bereitstellt. Die Einrichtung ist jedoch etwas umständlich, da DS-5 nicht ganz fehlerfrei ist und keinen klaren Leitfaden zum Erstellen eines Projekts bietet.

GCC ist eine der weitverbreitesten Compilersuiten, ist vollständig Open Source und in der Lage, für alle bekannten Architekturen und Betriebssysteme C, C++ und Assemblercode zu Binärcode umzubauen, wobei zusätzlich auch umfangreiche und effektive Optimisierungsoptionen vorhanden sind.

\section{Lösungsalternativen}
\subsection{Unsere Lösung -- Vector Floating Point (VFP)}
\subsection*{Vorstellung}
In der von uns enwickelten Lösung verwenden wir die Vector Floating Point Erweiterung von ARM. 
Diese erlaubt es uns mit Fließkommazahlen zu rechnen.
\subsection*{Vorteile}
\begin{itemize}
\item beliebige Menge an zu verarbeitenden Daten
\item lauffähig auch auf Architekturen ohne NEON
\end{itemize}
\subsection*{Nachteile}
\begin{itemize}
\item Langsam, da der VFP-Koprozessor nicht voll genutzt wird
\end{itemize}
\subsection{Alternative Lösung -- SIMD (NEON)}
In dieser alternativen Lösung wird der NEON Koprozessor von ARM verwendet, um von \emph{SIMD} (Single Instruction, Multiple Data)
zu profitieren. Das bedeutet, dass pro Assemblerbefehl nicht mit einem, sondern mit vier Zahlen gerechnet werden. Unsere Tests haben gezeigt, dass dadurch die Berechnung mindestens um Faktor 6 verschnellert wird.
\subsubsection{Vorteile}
\begin{itemize}
\item Um Faktor 6-8 schneller als VFP
\end{itemize}
\subsubsection{Nachteile}
\begin{itemize}
\item SIMD Befehle müssen jeweils zwei oder vier Fließkommazahlen verarbeiten. Falls die Eingabedatenmenge kein Vielfaches von vier ist, kann für den entsprechenden Rest nicht derselbe Code verwendet werden.
\item Der NEON Befehlssatz verfügt über keinen Divisionsbefehl. Die einzige Möglichkeit ist eine Annäherung an den Kehrbruch mit \emph{VRECPE} und anschließende Multiplikation. 
Die einmalige Annäherung ist dadurch nicht sehr genau, durch zweimalige Iteration des Newton-Raphson-Verfahrens mittels \emph{VRECPS} erreichen wir jedoch eine Genauigkeit von ~7 signifikanten Stellen, was sich als am praktikabelsten herausgestellt hat. 
\end{itemize}
\subsection{Entscheidungsprozess}
Um keine Entscheidung zugunsten einer Lösung treffen zu müssen, haben wir einfach alle Alternativen selbst implementiert.
%%TODO NEON haben wir nur beispielhaft implementiert, loop fehlt
\section{Dokumentation der Implementierung}
\subsection{Entwickler-Dokumentation}
\subsubsection{Rahmenprogramm}
Das in C geschriebene Rahmenprogramm liest die Datensätze mit den Radien der Kugelkondensatoren aus einer Textdatei in den Speicher.
Dann werden drei verschiedene Implementierungsvarianten ausgeführt (Assembler mit VFP, Assembler mit NEON und Vektorisierung und die C-Referenzimplementierung), deren Ergebnisse ausgegeben und die benötigte Zeit gemessen.
\subsubsection{Assemblerroutine - VFP}
%%calc
%%loop
%%capacity
%%TODO
\subsubsection{Assemblerroutine - NEON und Vektorisierung}
%%TODO
Da wir uns für eine Implementierung ohne Vektorisierung entschieden haben, haben wir den Aufrufcode nicht an die Vektorisierung angepasst und haben das NEON-Beispiel direkt mittels C-Code angesprochen.
\subsubsection{Optimierungen}
%%TODO
\subsection{Benutzer-Dokumentation}
%%TODO
\section{Ergebnisse}
\subsection{Vergleich von Assembler und C-Code}
\subsubsection{Genauigkeit der Ergebnisse}
%%TODO
\subsubsection{Laufzeit}
%%TODO
\subsection{Analyse und Bewertung}
%%TODO

\end{document}

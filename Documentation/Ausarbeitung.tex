\documentclass[11pt]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ersetzen Sie in den folgenden Zeilen die entsprechenden -Texte-
%% mit den richtigen Werten.
\newcommand{\theNumber}{1.77}
\newcommand{\theGroup}{$\pi$}
\newcommand{\theName}{Kugelkondensator mit Dielektrika Hartgummi und Hartpapier}

\newcommand{\nameM}{Moritz Mackiewicz}
\newcommand{\nameE}{Elias Marquart}
\newcommand{\nameC}{Claus Strasburger}
%%%%%%%%%%%

\input{asp_standard_lib}
%\include{__config}
\usepackage{hyperref}
\usepackage{amsmath}

\begin{document}

\sheetHeader{Projektaufgabe \theNumber : \theName}{Gruppe \theGroup}{\nameM}{\nameE}{\nameC}

\section{Problemstellung und Spezifikation}

\subsection{Aufgabenstellung}
In der von uns bearbeiteten Aufgabe geht es um die Berechnung der Kapazitäten von mehreren Kugelkondensatoren.
Dazu wird eine Liste von Kondensatorabmessungen in Form einer Textdatei eingegeben. Zu dieser dann in einem Assemblerprogramm die jeweiligen Kapazitäten für verschiedene Dielektrika berechnet werden.
Die Abmessungen bestehen jeweils aus zwei Radien, dem der inneren Kugel $r_{1}$ und dem der äußeren Kugel $r_{2}$.

Die Formel zur Berechnung der Kapazität eines Kugelkondesators lautet:

\begin{center}
\begin{math}
C= 4 \pi \varepsilon_{0} \varepsilon_{r} \frac{r_{1} \cdot r_{2}} {r_{2} - r_{1}}
\end{math}
\end{center}
BEGIN RAGE\\
Diese Formel lässt sich für die Berechnung mit Assembler vereinfachen, indem man sie in einzelne Schritte aufteilt und diese jeweils nacheinander ausrechnet.\\
END RAGE\\
MEINST DU DAS VERDAMMT NOCH MAL ERNST?

\subsection{Implementierungsumgebung}
Wir verwenden zur Entwicklung das \board, ein ARMv8-System mit NEON-VFP. Dieses erlaubt bla, bla und bla %%TODO

Unsere Entwicklungsumgebung besteht aus \emph{ARM Development Studio 5 für Eclipse}, \emph{GNU make} und \emph{gcc 4.7}.

\section{Lösungsalternativen}
\subsection{Unsere Lösung -- Vector Floating Point (VFP)}
\subsection*{Vorstellung}
In der von uns enwickelten Lösung verwenden wir die Vector Floating Point Erweiterung von ARM. 
Diese erlaubt es uns mit Floats und den Grundrechenarten zu rechnen.
\subsection*{Vorteile}
\begin{itemize}
\item beliebige Menge an zu verarbeitenden Daten
\end{itemize}
\subsection*{Nachteile}
\begin{itemize}
\item langsamer als SIMD
\end{itemize}
\subsection{Alternative Lösung -- SIMD (NEON)}
In dieser alternativen Lösung wird der NEON Koprozessor von ARM verwendet, um von SIMD (Single Instruction Multiple Data)
zu profitieren. Das bedeutet, dass pro Assemblerbefehl nicht mit einem, sondern mit vier Floats gerechnet werden. Dadurch wird die Berechnung um mindestens den Faktor 6 schneller, wie unsere Tests gezeigt haben.
\subsubsection{Vorteile}
\begin{itemize}
\item schnell
\end{itemize}
\subsubsection{Nachteile}
\begin{itemize}
\item SIMD Befehle müssen jeweils vier Floats(ein Quad-Word) verarbeiten. Bei einer Datensatzgröße die kein Teiler von 4 ist muss deshalb ein entsprechender Workaround gefunden werden.
\item Der NEON Befehlssatz verfügt über keinen Divisionsbefehl. Die einzige Möglichkeit ist eine Annäherung an den Kehrbruch mit \emph{VRECPE} und anschließende Multiplikation. 
Jedoch ist die einmalige Annäherung dadurch nicht sehr genau, wir erreichen jedoch durch mehrmalige Iteration des Newton-bla-Verfahrens unter Zuhilfenahme von \emph{VRECPS} eine Genauigkeit von ~7 signifikanten Stellen, was sich als am praktikabelsten herausgestellt hat. 
\end{itemize}
\subsection{Entscheidungsprozess}
Um keine Entscheidung zugunsten einer Lösung treffen zu müssen, haben wir einfach alle Alternativen selbst implementiert.
\section{Dokumentation der Implementierung}
\subsection{Entwickler-Dokumentation}
\subsubsection{Rahmenprogramm}
\subsubsection{Assemblerroutine}
\subsubsection{Optimierungen}
\subsection{Benutzer-Dokumentation}

\section{Ergebnisse}
\subsection{Vergleich von Assembler und C-Code}
\subsubsection{Genauigkeit der Ergebnisse}
\subsubsection{Laufzeit}
\subsection{Analyse und Bewertung}




\end{document}
